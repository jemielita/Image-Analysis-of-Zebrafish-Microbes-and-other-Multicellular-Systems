%saveCroppedBatch: for a given directory that has been cropped using
%multipleRegionCrop.m save the cropped region to a new directory, or
%overwrite the existing directory.
%
%USAGE: saveCroppedBatch(param, cropDir, fileType, cropType)
%    param: parameter file for a given directory of images. Generated by
%
%    multipleRegionCrop. Using multipleRegionCrop.m the user must have
%    cropped down the images to the desired size.
%
%    cropDir: the directory to save the cropped region to. This directory
%    can be the directory that the images are taken from. If it is this
%    program will overwrite the images in that directory
%
%    fileType: 'tiff' or 'png'. Save the result in either format
%
%    cropType: 'all', 'xy', or 'z'. Crop the images either in the 'xy' plane,
%    'z' plane or in both ('all'). Only 'xy' currently supported.
%
%AUTHOR: Matthew Jemielita

function saveCroppedBatch(param, cropDir, fileType,cropType)

%Get some needed variables.
totalNumRegions = length(unique([param.expData.Scan.region]));
totalNumScans = param.expData.totalNumberScans;
totalNumColors = size(param.color,2);

%Create a new directory structure if necessary
if(~strcmp(cropDir, param.directoryName))
    for nS=1:totalNumScans
        for nR = 1:totalNumRegions
            for nC = 1:totalNumColors
                dirName = [cropDir filesep 'Scans' filesep 'scan_', num2str(nS), filesep ...
                    'region_', num2str(nR), filesep param.color{nC}];
                mkdir(dirName);
            end
        end
    end
end

parameters = param.expData;
timeData = param.expData.timeData;

%Make a backup of the original experimentalData.mat files if we're
%overwriting the directory
if(strcmp(cropDir, param.directoryName))
   copyfile( [cropDir, filesep, 'ExperimentData.mat'],...
       [cropDir, filesep, 'ExperimentData.mat_backup']);
end

%Go through the directory structure and load the appropriate images,
%crop them, and then save the result as either a TIFF or PNG.

for nS=1:totalNumScans
    mess = ['Cropping scan ', num2str(nS)];
    fprintf(2, mess);
    for nC = 1:totalNumColors
        for nR = 1:totalNumRegions
            
            outputDirName = [cropDir filesep 'Scans' filesep 'scan_', num2str(nS), filesep ...
                'region_', num2str(nR), filesep param.color{nC}];
            inputDirName =  [param.directoryName filesep 'Scans' filesep 'scan_', num2str(nS), filesep ...
                'region_', num2str(nR), filesep param.color{nC}];
            
            index = find([param.expData.Scan.region]==nR,nC);
            index = index(nC);%Return the appropriate region for this color
            
            totalNumIm = param.expData.Scan(index).nImgsPerScan;%Assuming there are equal number of images in both channels...
            %a reasonable assumption.
            
            %Same code as in registerSingleImage.m
            %The the different regionExtent for different
            %colors-necessary if there was a glitch in image
            %acquisition that made the two colors offset...should be a
            %rare bug but we have seen it.
            if(length(param.regionExtent.XY)==1)
                thisRegion = param.regionExtent.XY;
            elseif(length(param.regionExtent.XY)==totalNumColors)
                thisRegion = param.regionExtent.XY{nC};
            else
                disp('The number of different colors in param.regionExtent.XY does not match the total number of colors!');
                return;
            end
            
            xOutI = thisRegion(nR,1);
            xOutF = thisRegion(nR,3)+xOutI-1;
            
            yOutI = thisRegion(nR,2);
            yOutF = thisRegion(nR,4)+yOutI -1;
            xInI = thisRegion(nR,5);
            xInF = xOutF - xOutI +xInI;
            
            yInI = thisRegion(nR,6);
            yInF = yOutF - yOutI +yInI;
            
            for nI = 1:totalNumIm
                fN = [inputDirName, filesep, 'pco', num2str(nI-1), '.tif'];
                %Loading in this image
                imI = imread(fN,...
                    'PixelRegion', {[xInI xInF], [yInI yInF]});
                %Saving this image to the new location, in either a
                %tiff or png format.
                switch fileType
                    case 'tiff'
                        fNout = [outputDirName, filesep, 'pco', num2str(nI-1), '.tif'];
                        imwrite(imI, fNout);
                    case 'png'
                        fNout = [outputDirName, filesep, 'pco', num2str(nI-1), '.png'];
                        imwrite(imI, fNout);
                        if(strcmp(cropDir, param.directoryName))
                            delete(fN);%If we're overwriting the original file, then delete the .tiff file and replace it with a .png
                        end
                end
                fprintf(2, '.');
            end
            
        end
    end
    
    fprintf(2, '\n');
end


%Saving the new range of pixel locations
for nC = 1:totalNumColors
    
    if(length(param.regionExtent.XY)==1)
        param.regionExtent.XY(:,5)= 1;
        param.regionExtent.XY(:,6) = 1;
    elseif(length(param.regionExtent.XY)==totalNumColors)
        param.regionExtent.XY{nC}(:,5) = 1;
        param.regionExtent.XY{nC}(:,6) = 1;
    else
        disp('The number of different colors in param.regionExtent.XY does not match the total number of colors!');
        return;
    end
end


%Note: currently not updating the experimentData.txt file!!!!
%Also save the full param structure so that we can use this to load in the
%appropriate variables after cropping the images.
if(~isdir([cropDir filesep 'gutOutline']))
    mkdir(cropDir, 'gutOutline');
end

param.directoryName = cropDir;

save([cropDir filesep 'gutOutline', filesep 'param.mat'], 'param');
save([cropDir filesep 'ExperimentData.mat'], 'parameters', 'timeData', 'param');


end